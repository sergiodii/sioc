# SIOC v1 - Documentação

## Visão Geral

A versão 1 do SIOC é uma reescrita completa do sistema de injeção de dependência, oferecendo uma API mais moderna, flexível e thread-safe. Esta versão utiliza containers isolados em vez de um singleton global.

## Características Principais

- **Containers Isolados**: Cada container é independente, permitindo múltiplos contextos
- **Thread Safety**: Uso de `sync.Map` para operações concorrentes seguras
- **API Limpa**: Interface mais intuitiva e fácil de usar
- **Generics**: Suporte completo a generics do Go 1.18+
- **Injeção por Tipo**: Resolve dependências baseado no tipo da interface ou struct
- **Inicialização Automática**: Suporte a métodos `Init()` para inicialização de dependências
- **Sanitização de Nomes**: Nomes de serviços são automaticamente sanitizados

## API Principal

### Criação de Container

```go
import "github.com/sergiodii/sioc/v1"

// Cria um novo container vazio
container := sioc.NewContainer()
```

### Registro de Dependências

```go
// Registra uma dependência diretamente
type MyService struct {
    Name string
}

service := &MyService{Name: "test"}
sioc.Inject(service, container)
```

### Resolução de Dependências

```go
// Resolve uma dependência por tipo
service := sioc.Get[*MyService](container)
```

### Inicialização com Dependências

```go
type DatabaseService struct {
    initialized bool
}

type UserService struct {
    db *DatabaseService
}

func (u *UserService) Init(db *DatabaseService) {
    u.db = db
}

// Registra as dependências
sioc.Inject(&DatabaseService{}, container)
sioc.Inject(&UserService{}, container)

// Inicializa todas as dependências
sioc.Init(container)
```

## Interfaces e Tipos

### ServiceContainer

```go
type ServiceContainer interface {
    Register(serviceKey string, serviceInstance any)
    Resolve(serviceKey string) (any, bool)
    ListAll() []any
    Count() int
}
```

Interface principal do container que define as operações básicas de registro e resolução.

### ServiceWrapper

```go
type ServiceWrapper[T any] interface {
    GetService() T
    CreateNewService() T
    MatchesServiceName(serviceName string) bool
    SetService(serviceInstance T) ServiceWrapper[T]
}
```

Interface genérica para wrappers de dependências, oferecendo funcionalidades avançadas.

### ServiceProvider

```go
type ServiceProvider interface {
    ProvideService() any
}
```

Interface para tipos que podem fornecer serviços customizados.

### InstanceCreationMode

```go
type InstanceCreationMode string

const (
    CreateNewInstance InstanceCreationMode = "CREATE_NEW"
)
```

Tipo para indicar modos de criação de instâncias.

## Exemplos de Uso

### Exemplo Básico

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v1"
)

type UserService struct {
    Name string
}

func main() {
    // Cria um novo container
    container := sioc.NewContainer()
    
    // Registra o serviço
    userService := &UserService{Name: "admin"}
    sioc.Inject(userService, container)
    
    // Resolve o serviço
    service := sioc.Get[*UserService](container)
    fmt.Println(service.Name) // Output: admin
}
```

### Exemplo com Inicialização

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v1"
)

type Database struct {
    Connected bool
}

func (d *Database) Init() {
    d.Connected = true
    fmt.Println("Database connected")
}

type UserService struct {
    db *Database
}

func (u *UserService) Init(db *Database) {
    u.db = db
    fmt.Println("UserService initialized with database")
}

func main() {
    container := sioc.NewContainer()
    
    // Registra as dependências
    sioc.Inject(&Database{}, container)
    sioc.Inject(&UserService{}, container)
    
    // Inicializa todas as dependências
    sioc.Init(container)
    
    // Resolve o serviço
    userService := sioc.Get[*UserService](container)
    fmt.Printf("UserService has database: %v\n", userService.db.Connected)
}
```

### Exemplo com Interface

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v1"
)

type Logger interface {
    Log(message string)
}

type ConsoleLogger struct{}

func (c *ConsoleLogger) Log(message string) {
    fmt.Println("LOG:", message)
}

type Service struct {
    logger Logger
}

func (s *Service) Init(logger Logger) {
    s.logger = logger
}

func main() {
    container := sioc.NewContainer()
    
    // Registra o logger
    sioc.Inject(&ConsoleLogger{}, container)
    sioc.Inject(&Service{}, container)
    
    // Inicializa
    sioc.Init(container)
    
    // Resolve o serviço
    service := sioc.Get[*Service](container)
    service.logger.Log("Hello from service")
}
```

### Exemplo com ServiceWrapper

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v1"
)

type ConfigService struct {
    APIKey string
}

func main() {
    container := sioc.NewContainer()
    
    // Cria um wrapper para o serviço
    wrapper := sioc.NewServiceWrapper[*ConfigService]()
    config := &ConfigService{APIKey: "secret-key"}
    wrapper.SetService(config)
    
    // Registra o wrapper
    container.Register("config", wrapper)
    
    // Resolve o serviço
    service := sioc.Get[*ConfigService](container)
    fmt.Println("API Key:", service.APIKey)
}
```

### Exemplo com Múltiplos Containers

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v1"
)

type UserService struct {
    Name string
}

func main() {
    // Cria containers separados para diferentes contextos
    devContainer := sioc.NewContainer()
    prodContainer := sioc.NewContainer()
    
    // Registra serviços diferentes em cada container
    sioc.Inject(&UserService{Name: "dev-user"}, devContainer)
    sioc.Inject(&UserService{Name: "prod-user"}, prodContainer)
    
    // Resolve serviços de cada container
    devService := sioc.Get[*UserService](devContainer)
    prodService := sioc.Get[*UserService](prodContainer)
    
    fmt.Println("Dev:", devService.Name)   // Output: Dev: dev-user
    fmt.Println("Prod:", prodService.Name) // Output: Prod: prod-user
}
```

### Exemplo para Testes

```go
package main

import (
    "testing"
    "github.com/sergiodii/sioc/v1"
)

type MockDatabase struct {
    Connected bool
}

func (m *MockDatabase) Init() {
    m.Connected = true
}

type UserService struct {
    db *MockDatabase
}

func (u *UserService) Init(db *MockDatabase) {
    u.db = db
}

func TestUserService(t *testing.T) {
    // Cria um container específico para o teste
    container := sioc.NewContainer()
    
    // Registra dependências mock
    sioc.Inject(&MockDatabase{}, container)
    sioc.Inject(&UserService{}, container)
    
    // Inicializa
    sioc.Init(container)
    
    // Testa o serviço
    userService := sioc.Get[*UserService](container)
    if !userService.db.Connected {
        t.Error("Database should be connected")
    }
}
```

## Funções Utilitárias

### GetFunctionName

```go
func GetFunctionName(functionValue interface{}) string
```

Retorna o nome de uma função a partir de seu valor.

### Operações do Container

```go
// Lista todos os serviços registrados
allServices := container.ListAll()

// Conta o número de serviços
count := container.Count()

// Resolve por chave específica
service, found := container.Resolve("service-key")
```

## Vantagens da v1

1. **Flexibilidade**: Containers isolados permitem múltiplos contextos
2. **Thread Safety**: Operações concorrentes seguras
3. **Testabilidade**: Fácil criação de containers para testes
4. **API Limpa**: Interface mais intuitiva e moderna
5. **Generics**: Suporte completo a tipos genéricos
6. **Sanitização**: Nomes de serviços são automaticamente limpos
7. **Compatibilidade**: Alias para compatibilidade com v0

## Migração da v0

Para migrar da v0 para v1:

1. **Substitua o singleton global** por containers locais
2. **Use `NewContainer()`** em vez de `Start()`
3. **Use `Inject()`** em vez de `Register()`
4. **Use `Get[T]()`** com o container como parâmetro
5. **Passe o container** para todas as operações

### Exemplo de Migração

```go
// v0
sioc.Start()
sioc.Register(&MyService{})
service := sioc.Get[*MyService]()

// v1
container := sioc.NewContainer()
sioc.Inject(&MyService{}, container)
service := sioc.Get[*MyService](container)
```

## Compatibilidade

A v1 mantém compatibilidade com a v0 através de:

- **Alias `Container`**: `type Container = ServiceContainer`
- **Métodos de compatibilidade**: Disponíveis internamente para testes
- **Mesma lógica de resolução**: Algoritmo similar para encontrar dependências
