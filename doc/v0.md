# SIOC v0 - Documentação

## Visão Geral

A versão 0 do SIOC é a implementação inicial do sistema de injeção de dependência. Esta versão utiliza um padrão singleton global com uma lista de injetores para gerenciar dependências.

## Características Principais

- **Singleton Global**: Usa um padrão singleton para gerenciar todas as dependências
- **Injeção por Tipo**: Resolve dependências baseado no tipo da interface ou struct
- **Inicialização Automática**: Suporte a métodos `Init()` para inicialização de dependências
- **Criação de Novas Instâncias**: Suporte para criar novas instâncias durante a inicialização
- **Interface IInjector**: Permite injeção customizada através de interfaces

## API Principal

### Inicialização

```go
import "github.com/sergiodii/sioc/v0"

// Inicializa o sistema de injeção
sioc.Start()
```

### Registro de Dependências

```go
// Registra uma dependência (deve ser um ponteiro)
type MyService struct {
    Name string
}

service := &MyService{Name: "test"}
sioc.Register(service)
```

### Resolução de Dependências

```go
// Resolve uma dependência por tipo
service := sioc.Get[*MyService]()
```

### Inicialização com Dependências

```go
type DatabaseService struct {
    initialized bool
}

type UserService struct {
    db *DatabaseService
}

func (u *UserService) Init(db *DatabaseService) {
    u.db = db
}

// Registra as dependências
sioc.Register(&DatabaseService{})
sioc.Register(&UserService{})

// Inicializa todas as dependências
sioc.Init()
```

## Tipos e Interfaces

### IInjector

```go
type IInjector interface {
    InjectorInsertion() any
}
```

Interface que permite injeção customizada. Quando um tipo implementa esta interface, o método `InjectorInsertion()` é chamado para obter o objeto a ser injetado.

### InitializeNewInstanceTo

```go
type InitializeNewInstanceTo string

const (
    NEW InitializeNewInstanceTo = "NEW"
)
```

Tipo usado para indicar que uma nova instância deve ser criada durante a inicialização.

## Exemplos de Uso

### Exemplo Básico

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v0"
)

type UserService struct {
    Name string
}

func main() {
    // Inicializa o sistema
    sioc.Start()
    
    // Registra o serviço
    userService := &UserService{Name: "admin"}
    sioc.Register(userService)
    
    // Resolve o serviço
    service := sioc.Get[*UserService]()
    fmt.Println(service.Name) // Output: admin
}
```

### Exemplo com Inicialização

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v0"
)

type Database struct {
    Connected bool
}

func (d *Database) Init() {
    d.Connected = true
    fmt.Println("Database connected")
}

type UserService struct {
    db *Database
}

func (u *UserService) Init(db *Database) {
    u.db = db
    fmt.Println("UserService initialized with database")
}

func main() {
    sioc.Start()
    
    // Registra as dependências
    sioc.Register(&Database{})
    sioc.Register(&UserService{})
    
    // Inicializa todas as dependências
    sioc.Init()
    
    // Resolve o serviço
    userService := sioc.Get[*UserService]()
    fmt.Printf("UserService has database: %v\n", userService.db.Connected)
}
```

### Exemplo com Interface

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v0"
)

type Logger interface {
    Log(message string)
}

type ConsoleLogger struct{}

func (c *ConsoleLogger) Log(message string) {
    fmt.Println("LOG:", message)
}

type Service struct {
    logger Logger
}

func (s *Service) Init(logger Logger) {
    s.logger = logger
}

func main() {
    sioc.Start()
    
    // Registra o logger
    sioc.Register(&ConsoleLogger{})
    sioc.Register(&Service{})
    
    // Inicializa
    sioc.Init()
    
    // Resolve o serviço
    service := sioc.Get[*Service]()
    service.logger.Log("Hello from service")
}
```

### Exemplo com IInjector

```go
package main

import (
    "fmt"
    "github.com/sergiodii/sioc/v0"
)

type CustomService struct {
    Name string
}

type ServiceProvider struct{}

func (s *ServiceProvider) InjectorInsertion() any {
    return &CustomService{Name: "injected"}
}

func main() {
    sioc.Start()
    
    // Registra o provedor
    sioc.Register(&ServiceProvider{})
    
    // Inicializa
    sioc.Init()
    
    // Resolve o serviço customizado
    service := sioc.Get[*CustomService]()
    fmt.Println(service.Name) // Output: injected
}
```

## Funções Utilitárias

### GetFunctionName

```go
func GetFunctionName(temp interface{}) string
```

Retorna o nome de uma função a partir de seu valor.

### Len

```go
func Len() int
```

Retorna o número de dependências registradas.

### ClearList

```go
func ClearList()
```

Limpa todas as dependências registradas.

## Limitações da v0

1. **Singleton Global**: Todas as dependências são gerenciadas globalmente
2. **Thread Safety**: Não é thread-safe por padrão
3. **API Limitada**: Menos flexibilidade na configuração
4. **Dependências Globais**: Dificulta testes unitários isolados

## Migração para v1

A v1 oferece uma API mais moderna e flexível:

- **Containers Isolados**: Cada container é independente
- **Thread Safety**: Uso de `sync.Map` para segurança
- **API Mais Limpa**: Interface mais intuitiva
- **Melhor Testabilidade**: Containers podem ser criados para testes

Para migrar da v0 para v1, consulte a [documentação da v1](./v1.md).
